¿Qué necesito? Solo los agentes Comprador y Subastador. Pero también es necesario lanzar el Reloj.

Para realizar la subasta, solo existirá un tipo de lote. El lote tendrá el precio de salida y el mínimo.
El comprador tendrá su precio objetivo. Todo eso será fijo y se lo pasaré al Subastador.

Primero comprobaré que se comunican en el primer estado y directamente pasarán al estado final en el que simplemente
se enviarán un mensaje.

Orden:

Configurar el Launcher para que solo lance estos dos agentes.
El AuctioneerAgent se suscribe en el DF y el Buyer lo busca. Entonces el Buyer debe de suscribirse al AuctionerAgent, ya que esto ya lo tenemos implementado. También necesitan al Clock.
Tras esto podrán comunicarse. Es necesario eliminar otros comportamientos. Buscar otros agentes o realizar suscripciones u otros comportamientos que puedan ser ejecutados.
El plan es que aparezcan el menor número de mensajes. Vamos a intentar hacer las cosas a través del HTML pero mostrando algunos mensajes por consola también.


A ExternalAgent le quito la suscripción al agente de registro. A BuyerAgent le quito las suscripciones que no necesito.
Elimino la suscripción a la subasta. Eso lo añadiré más adelante.

El primer estado será el de notificar el comienzo de la subasta. El subastador no envía respuesta, espera al priemr CFP. Esto ya está implementado en AuctioneerAgent.
Registro el primer estado y paso directamente al final.

Voy a probar el FSM: Crearé un agente normal que tengo LOG que solo tendrá un comportamiento FSM. Con este puedo ir haciendo pruebas con el FSM. Este agente añade el FSM y ya está.
Así veré los LOGS. En el Launcher tendré que lanzar solo este agente.

AgenteFSM: Tres estados con varias transiciones. Funciona correctamente. Importante: si se crean transiciones normales, el valor que se indica es lo que tiene que devolver el
método onEnd del estado s1. Así es como se pueden crear varias transiciones desde un mismo estado a varios.
Si volvemos a un estado ya visitado NO es necesario hacer un reset de ese estado. El estado funcionará correctamente. Lo normal será usar OneShotBehaviour. ¡Si uso un CyclicBehaviour nunca se
sale del estado! ya que este ¡NO termina!

Por lo tanto, para que funcione correctamente, crear los estados y crear transiciones por defecto si de un estado se pasa a otro y siempre se pasará a ese.
Si podemos pasar a dos estados crear dos transiciones normales con un evento de transición para cada una. Este código se deve devolver en el método onEnd de s1
según alguna lógica.

El reset es para resetear un comportamiento. Destruye un comportamiento y lo vuelve a crear. La función principal del método es realizar múltiples comportamientos cíclicos sin necesidad
de construcciones complciadas y eliminación de objetos en cada iteración.

Con esto ya puedo crear los dos FSMBehaviour de prueba para BuyerAgent y AuctioneerAgent.

Ahora paso a crear el FSM de AuctioneerAgent y BuyerAgent:
Primero serán con un estado inicial y uno final. El Auctioneer enviará un mensaje de inicio y de fin y el Buyer lo recibirá.
Como tenemos que crera el protocolo de Dutch Auction tenemos que usar FSM con OneShotBehaviour ya que algunos estados envían mensajes sin esperar respuesta.
Por eso el AuctioneerAgent envía los mensajes a través de OneShotBehaviour y el BuyerAgent los recibe a través de MsgReceiver.
No llegaba el mensaje por el FSM en el BuyerAgent. El problema es que en el subastador lo notificaba a través de la subscripción por lo que el comportamiento
que recibe este mensaje es el de FishSubsInitiator y no el FSM que es un MsgReceiver. Por lo tanto, en el subastador no debo de usar el método notify de subscription.
Debo de enviar el mensaje de manera normal, con send.

¿Cómo realizar la subasta varias veces?
FSmBehaviour es un comportamiento OneShot por lo que al terminar se borra de la cola de comportamientos y no se puede hacer un reset del comportamiento.
Por lo tanto, para realizarlo de nuevo es necesario crear el comportamiento de nuevo y añadirlo otra vez. Lo estoy haciendo en el onEnd del último estado.
En el caso del proyecto real habrá que añadir el FSM en el Subastador cuando el Agente de Fases notifique la fase de la subasta. En el caso del Comprador
habrá que añadir el FSM al principio y cuando este termine ya que al ser un MsgReceiver espera su momento. Comprobar en este caso, si se puede usar el mismo objeto
Behaviour. Creo que no, creo que siempre habrá que crear uno nuevo.

En las pruebas si vuelvo a introducir el comportamiento en ambos agentes envían y reciben los mensajes continuamente. En ese caso, puede ser que el Subastador envíe
mensajes más rápido que lo que el comprador puede recibir, pero el comprador siempre los recibirá y en orden. Si hay más de un mensaje en cola y paro el subastador,
el comprador los recibirá todos en orden y al terminar no se mostrarán más textos en la consola.


Para realizar la subasta con el comprador: Primero creo el lote, y asigno los precios y el decremento del precio. Después hay que crear los estados en el Subastador.
Es necesario crear el envío de los precios: Envía CFP y pasa a un estado de espera, en el que espera recibir un mensaje. En este estado espera x segundos y según si recibe
un mensaje o no, pasa a un estado u otro.

En el caso de la Subasta hay dos opciones. O todos los compradores están obligados a enviar un propose y uso ProposeInitiator y ProposeResponder o uso MsgReceiver con un timeout.
Con Propose se puede indicar un tiemout pero en el iniciador, es decir, el comprador pero no en el que responde, el Subastador.